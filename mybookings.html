<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>My Bookings – WaveTravel</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap" rel="stylesheet"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Poppins', sans-serif;
    }
    body {
      background: linear-gradient(to right, #16425b, #81c3d7);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding-bottom: 80px;
    }
    .container {
      flex: 1;
      padding: 16px;
    }
    h1 {
      text-align: center;
      color: #fff;
      margin-bottom: 16px;
    }
    .booking-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .booking-card {
      background: #fff;
      padding: 16px;
      border-radius: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      border-left: 6px solid #0077ff;
      position: relative;
    }
    .card-number {
      position: absolute;
      top: -12px;
      left: -12px;
      background: #0077ff;
      color: #fff;
      font-weight: bold;
      font-size: 0.85rem;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    .booking-card h3 {
      margin-bottom: 12px;
      font-size: 1rem;
      color: #333;
    }
    .info {
      display: flex;
      align-items: center;
      margin: 6px 0;
      font-size: 0.9rem;
      color: #444;
    }
    .info i {
      color: #0077ff;
      margin-right: 8px;
      width: 20px;
      text-align: center;
    }

    /* Fare + call button styling */
    .fare-row {
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:10px;
      justify-content:flex-start;
      flex-wrap:wrap;
    }
    .fare-text {
      font-weight:700;
      color:#28a745;
      font-size:1rem;
      background: rgba(40,167,69,0.06);
      padding: 8px 12px;
      border-radius: 8px;
      min-width: 110px;
      text-align:left;
      box-shadow: 0 6px 14px rgba(40,167,69,0.04);
    }
    .call-btn {
      display:inline-flex;
      align-items:center;
      gap:8px;
      background:#0077ff;
      color:#fff;
      padding:8px 10px;
      border-radius:8px;
      text-decoration:none;
      font-weight:700;
      font-size:0.9rem;
      border: none;
      box-shadow: 0 6px 14px rgba(0,119,255,0.08);
    }
    .call-btn i { font-size: 0.95rem; }

    .call-btn[aria-disabled="true"], .call-btn.disabled {
      background:#e6eefc;
      color:#7b8aa9;
      box-shadow:none;
      cursor:not-allowed;
      pointer-events:none;
      opacity:0.95;
    }

    .fare-note { color:#6b7280; font-size:0.85rem; margin-left:6px; }

    .navbar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #fff;
      display: flex;
      justify-content: space-around;
      padding: 8px 0;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    .navbar a {
      text-decoration: none;
      color: #0077ff;
      font-size: 12px;
      text-align: center;
    }
    .navbar a i {
      display: block;
      font-size: 20px;
      margin-bottom: 4px;
    }

    /* review button & badge */
    .review-btn {
      background: #ff8a00;
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight:700;
      border: none;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(255,138,0,0.08);
      display: inline-flex;
      align-items:center;
      gap:8px;
      margin-left: 8px;
    }
    .review-btn.disabled {
      background:#ffe9d6;
      color:#7b5b3a;
      pointer-events:none;
      opacity:0.9;
    }
    .reviewed-badge {
      display:inline-block;
      padding:6px 10px;
      background:#eef2ff;
      color:#4338ca;
      border-radius:8px;
      font-weight:700;
      margin-left:8px;
      font-size:0.9rem;
    }

    /* small rating display */
    .driver-rating {
      display:inline-flex;
      align-items:center;
      gap:8px;
      margin-left: auto;
      font-size:0.9rem;
      color:#374151;
    }

    /* modal styles */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal {
      width: 92%;
      max-width: 420px;
      background: #fff;
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    .modal h2 { margin-bottom: 12px; font-size:1.1rem; color:#111827; }
    .stars { display:flex; gap:8px; margin:12px 0; }
    .star {
      font-size: 28px;
      cursor: pointer;
      opacity: 0.45;
      transition: opacity .12s, transform .08s;
    }
    .star.selected { opacity: 1; transform: scale(1.08); color: #ffb020; }
    .modal textarea {
      width:100%;
      min-height:80px;
      border-radius:8px;
      border:1px solid #e5e7eb;
      padding:8px;
      resize:vertical;
      font-family: inherit;
    }
    .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
    .btn { padding:8px 12px; border-radius:8px; font-weight:700; border:none; cursor:pointer; }
    .btn.secondary { background:#eef2ff; color:#0077ff; }
    .btn.primary { background:#0077ff; color:#fff; }

    /* small spinner */
    .spinner {
      border: 3px solid rgba(0,0,0,0.06);
      border-left-color: rgba(0,0,0,0.18);
      height: 18px;
      width: 18px;
      border-radius: 50%;
      display: inline-block;
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* responsive tweaks */
    @media (max-width:480px){
      .fare-text { min-width:100px; font-size:0.95rem; padding:8px 10px; }
      .call-btn { padding:8px 10px; font-size:0.9rem;}
      .info { font-size:0.88rem; }
    }

  </style>
</head>
<body>

  <div class="container">
    <h1>My Bookings</h1>
    <div id="bookings" class="booking-list">
      <!-- Populated by JavaScript -->
    </div>
  </div>

  <div class="navbar">
    <a href="customerdashboard.html"><i class="fas fa-home"></i>Home</a>
    <a href="booking.html"><i class="fas fa-car"></i>Book</a>
    <a href="mybookings.html"><i class="fas fa-calendar-check"></i>Bookings</a>
    <a href="profile.html"><i class="fas fa-user"></i>Profile</a>
  </div>

  <!-- Firebase SDKs (v8) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDsn16p7w8b-x8pEA_WTO5F2oUk4MHwcUc",
      authDomain: "wavetravel-3c4c4.firebaseapp.com",
      databaseURL: "https://wavetravel-3c4c4-default-rtdb.firebaseio.com",
      projectId: "wavetravel-3c4c4",
      storageBucket: "wavetravel-3c4c4.appspot.com",
      messagingSenderId: "298226098137",
      appId: "1:298226098137:web:720953b80e3e61c8bc43c8"
    };
    firebase.initializeApp(firebaseConfig);

    const auth = firebase.auth();
    const db = firebase.database();
    const bookingsEl = document.getElementById('bookings');

    // ------------------ helper functions (kept & extended) ------------------
    function to12Hour(time) {
      if (!time || typeof time !== 'string') return time || '—';
      let parts = time.split(':');
      if (parts.length < 2) return time;
      let [h, m] = parts.map(Number);
      const suffix = h >= 12 ? 'PM' : 'AM';
      h = h % 12 || 12;
      return `${h}:${String(m).padStart(2,'0')} ${suffix}`;
    }
    function formatDate(d) {
      if (!d) return '—';
      const dt = new Date(d);
      if (!isNaN(dt)) {
        return dt.toLocaleDateString(undefined, {
          year: 'numeric', month: 'short', day: 'numeric'
        });
      }
      return d;
    }

    // derive pickup timestamp (epoch ms) from booking object (best-effort)
    function getPickupTimestamp(b) {
      if (!b) return null;
      
      // Handle evplan structure (pickupTimestamp is in seconds)
      if (b.source === 'evplan' && b.pickupTimestamp) {
        const ts = Number(b.pickupTimestamp);
        if (!isNaN(ts)) {
          // Convert seconds to milliseconds
          return ts * 1000;
        }
      }
      
      // Handle old structure
      if (b.pickupTime) {
        const n = Number(b.pickupTime);
        if (!isNaN(n)) return n;
      }
      if (b.date && typeof b.date === 'number') return b.date;
      if (b.date && b.time) {
        const combined = `${b.date} ${b.time}`;
        const parsed = Date.parse(combined);
        if (!isNaN(parsed)) return parsed;
        const d = (b.date || '').toString().trim();
        const t = (b.time || '').toString().trim();
        const parts = d.includes('-') ? d.split('-') : (d.includes('/') ? d.split('/') : null);
        if (parts && parts.length === 3) {
          let day = parts[0], month = parts[1], year = parts[2];
          if (parts[0].length === 4) { year = parts[0]; month = parts[1]; day = parts[2]; }
          if (parts[2].length === 4) { year = parts[2]; month = parts[1]; day = parts[0]; }
          const iso = `${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')} ${t}`;
          const parsed2 = Date.parse(iso);
          if (!isNaN(parsed2)) return parsed2;
        }
      }
      if (b.date) {
        const parsed = Date.parse(b.date);
        if (!isNaN(parsed)) return parsed;
      }
      return null;
    }

    // ensure bookings/{driverId}/{bookingId}/pickupTime numeric exists (returns numeric TS or null)
    async function ensurePickupTimeIfMissing(booking) {
      if (!booking) return null;
      
      // Skip for evplan bookings - they use pickupTimestamp (seconds)
      if (booking.source === 'evplan') {
        if (booking.pickupTimestamp && !isNaN(Number(booking.pickupTimestamp))) {
          return Number(booking.pickupTimestamp) * 1000; // Convert to ms
        }
        return null;
      }
      
      // Only process old-structure bookings
      try {
        if (booking.pickupTime && !isNaN(Number(booking.pickupTime))) {
          return Number(booking.pickupTime);
        }
        // compute from other fields
        const ts = getPickupTimestamp(booking);
        if (!ts) return null;
        // update booking record (only allowed if you are booking owner / driver according to your rules)
        const bookingRef = db.ref(`bookings/${booking.driverId}/${booking.id}`);
        await bookingRef.update({ pickupTime: ts });
        // reflect local change
        booking.pickupTime = ts;
        return ts;
      } catch (err) {
        console.warn('Could not ensure pickupTime for booking', booking.id, err);
        return null;
      }
    }

    // get server time now using .info/serverTimeOffset
    async function getServerTimeNow() {
      try {
        const snap = await db.ref('.info/serverTimeOffset').once('value');
        const offset = snap.val() || 0;
        return Date.now() + offset;
      } catch (e) {
        return Date.now();
      }
    }

    // small toast
    function toast(msg, ms = 2500) {
      const t = document.createElement('div');
      t.style.position = 'fixed';
      t.style.bottom = '90px';
      t.style.left = '50%';
      t.style.transform = 'translateX(-50%)';
      t.style.background = 'rgba(0,0,0,0.8)';
      t.style.color = '#fff';
      t.style.padding = '10px 14px';
      t.style.borderRadius = '8px';
      t.style.zIndex = 3000;
      t.textContent = msg;
      document.body.appendChild(t);
      setTimeout(() => t.remove(), ms);
    }

    // ------------------ modal and star UI ------------------
    let currentBookingForModal = null;
    function createReviewModal() {
      if (document.getElementById('review-modal-root')) return;
      const root = document.createElement('div');
      root.id = 'review-modal-root';
      root.style.display = 'none';
      document.body.appendChild(root);

      root.innerHTML = `
        <div class="modal-backdrop" id="review-backdrop" style="display:none;">
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="review-title">
            <h2 id="review-title">Review Driver</h2>
            <div id="review-driver-info" style="font-size:0.95rem;color:#374151;margin-bottom:8px;"></div>
            <div class="stars" id="review-stars">
              <i class="fa-regular fa-star star" data-value="1"></i>
              <i class="fa-regular fa-star star" data-value="2"></i>
              <i class="fa-regular fa-star star" data-value="3"></i>
              <i class="fa-regular fa-star star" data-value="4"></i>
              <i class="fa-regular fa-star star" data-value="5"></i>
            </div>
            <textarea id="review-comment" placeholder="Write a short comment (optional)"></textarea>
            <div class="actions">
              <button class="btn secondary" id="review-cancel">Cancel</button>
              <button class="btn primary" id="review-submit">Submit Review</button>
            </div>
          </div>
        </div>
      `;

      const backdrop = document.getElementById('review-backdrop');
      const stars = root.querySelectorAll('.star');

      function highlightStars(n) {
        stars.forEach(s => {
          const v = Number(s.dataset.value);
          if (v <= n) {
            s.classList.add('selected');
            s.classList.remove('fa-regular');
            s.classList.add('fa-solid');
          } else {
            s.classList.remove('selected');
            s.classList.remove('fa-solid');
            s.classList.add('fa-regular');
          }
        });
      }

      stars.forEach(s => {
        s.addEventListener('mouseenter', () => highlightStars(Number(s.dataset.value)));
        s.addEventListener('mouseleave', () => {
          const sel = Number(root.dataset.selected || 0);
          highlightStars(sel);
        });
        s.addEventListener('click', () => {
          root.dataset.selected = s.dataset.value;
          highlightStars(Number(s.dataset.value));
        });
      });

      root.querySelector('#review-cancel').addEventListener('click', () => {
        backdrop.style.display = 'none';
        root.style.display = 'none';
        root.dataset.selected = 0;
        highlightStars(0);
      });

      backdrop.addEventListener('click', (e) => {
        if (e.target === backdrop) {
          backdrop.style.display = 'none';
          root.style.display = 'none';
          root.dataset.selected = 0;
          highlightStars(0);
        }
      });

      root.querySelector('#review-submit').addEventListener('click', async () => {
        const rating = Number(root.dataset.selected || 0);
        const comment = document.getElementById('review-comment').value.trim();
        if (!rating || rating < 1 || rating > 5) {
          alert('Please select rating 1–5.');
          return;
        }
        if (!currentBookingForModal) {
          alert('No booking selected.');
          return;
        }
        try {
          // visual feedback
          const submitBtn = root.querySelector('#review-submit');
          submitBtn.disabled = true;
          submitBtn.innerHTML = `<span class="spinner"></span> Submitting`;

          // call main submit function
          await fullClientReviewFlow(currentBookingForModal.booking, currentBookingForModal.driverId, rating, comment);

          // close modal
          backdrop.style.display = 'none';
          root.style.display = 'none';
          root.dataset.selected = 0;
          highlightStars(0);
          document.getElementById('review-comment').value = '';
        } catch (err) {
          console.error('Submit review error', err);
          alert('Failed to submit review: ' + (err && err.message ? err.message : 'unknown'));
        } finally {
          const submitBtn = root.querySelector('#review-submit');
          submitBtn.disabled = false;
          submitBtn.innerHTML = 'Submit Review';
        }
      });

      // expose open function
      window.openReviewModal = function(booking, driverId) {
        currentBookingForModal = { booking, driverId };
        const info = document.getElementById('review-driver-info');
        info.textContent = `Booking: ${booking.id} — Driver: ${booking.driverName || driverId}`;
        root.style.display = '';
        backdrop.style.display = 'flex';
      };
    }

    // ------------------ main rendering & logic ------------------
    auth.onAuthStateChanged(async (user) => {
      if (!user) {
        alert('Please log in first.');
        return window.location = 'index.html';
      }

      createReviewModal();

      try {
        // Fetch from BOTH old /bookings and new /evplan/bookings
        const [oldSnap, evplanSnap] = await Promise.all([
          db.ref('bookings').once('value'),
          db.ref('evplan/bookings').once('value')
        ]);

        const allDrivers = oldSnap.val() || {};
        const evplanBookings = evplanSnap.val() || {};
        const myBookings = [];

        // collect bookings from old structure (bookings/{driverId}/{bookingId})
        Object.entries(allDrivers).forEach(([driverId, bookings]) => {
          if (!bookings) return;
          Object.entries(bookings).forEach(([bookingId, b]) => {
            if (b.userId === user.uid || b.customerId === user.uid) {
              myBookings.push({ id: bookingId, driverId, source: 'old', ...b });
            }
          });
        });

        // collect bookings from new structure (evplan/bookings/{bookingId})
        Object.entries(evplanBookings).forEach(([bookingId, b]) => {
          if (b.riderId === user.uid) {
            myBookings.push({ 
              id: bookingId, 
              driverId: b.assignedDriverId || 'unknown',
              source: 'evplan',
              ...b 
            });
          }
        });

        if (myBookings.length === 0) {
          bookingsEl.innerHTML = `<p style="color:#fff; text-align:center;">No bookings found.</p>`;
          return;
        }

        // Ensure pickupTime exists for each booking (client computes and writes if missing).
        // We do this BEFORE eligibility checks so server rules that require pickupTime succeed.
        await Promise.all(myBookings.map(async (b) => {
          try {
            await ensurePickupTimeIfMissing(b);
          } catch (e) {
            console.warn('ensurePickupTimeIfMissing failed for', b.id, e);
          }
        }));

        // Now render cards (uses possibly updated pickupTime)
        bookingsEl.innerHTML = myBookings.map((b, i) => {
          // Handle both old and new data structures
          const isEvplan = b.source === 'evplan';
          
          // Date and time formatting
          let displayDate, displayTime;
          if (isEvplan && b.pickupTimestamp) {
            const pickupDt = new Date(b.pickupTimestamp * 1000);
            displayDate = pickupDt.toLocaleDateString(undefined, {
              year: 'numeric', month: 'short', day: 'numeric'
            });
            displayTime = pickupDt.toLocaleTimeString(undefined, {
              hour: '2-digit', minute: '2-digit'
            });
          } else {
            displayDate = formatDate(b.date);
            displayTime = to12Hour(b.time);
          }

          // Pickup and dropoff
          const pickup = isEvplan ? (b.pickup?.address || 'N/A') : (b.pickup || 'N/A');
          const dropoff = isEvplan ? (b.dropoff?.address || 'N/A') : (b.dropoff || 'N/A');

          // Car details
          let carText;
          if (isEvplan) {
            carText = b.vehicleType ? `${b.vehicleType.toUpperCase()}` : 'N/A';
            if (b.assignedDriverVehicle) {
              carText += ` (${b.assignedDriverVehicle})`;
            }
          } else {
            carText = (b.carBrand ? b.carBrand : '—') + (b.carReg ? ` (${b.carReg})` : '');
          }

          // Fare
          const fareValue = isEvplan ? b.fareEstimate : b.fare;
          const fareText = (fareValue !== undefined && fareValue !== null) ? `₹${fareValue}` : 'N/A';

          // Driver phone
          let driverNumber;
          if (isEvplan) {
            driverNumber = (b.assignedDriverPhone || '').toString().trim();
          } else {
            driverNumber = (b.driverNumber || b.driver_phone || b.driverPhone || b.driverContact || '').toString().trim();
          }
          const hasPhone = driverNumber.length > 0;
          const callBtn = hasPhone
            ? `<a class="call-btn" href="tel:${encodeURIComponent(driverNumber)}" aria-label="Call driver ${driverNumber}"><i class="fas fa-phone"></i> Call Driver</a>`
            : `<button class="call-btn disabled" aria-disabled="true" title="Driver number not available"><i class="fas fa-phone"></i> Call Driver</button>`;

          // Status badge for evplan bookings
          const statusBadge = isEvplan && b.status ? `
            <div class="info">
              <i class="fas fa-info-circle"></i> 
              <span>Status: <strong style="color: ${b.status === 'booked' ? '#10b981' : '#64748b'}">${b.status}</strong></span>
            </div>` : '';

          // Trip type for evplan
          const tripType = isEvplan && b.tripType ? `
            <div class="info">
              <i class="fas fa-route"></i> 
              <span>${b.tripType === 'roundtrip' ? 'Round Trip' : 'One Way'}</span>
            </div>` : '';

          // Distance and duration for evplan
          const distanceInfo = isEvplan && b.distance ? `
            <div class="info">
              <i class="fas fa-road"></i> 
              <span>${b.distance} km • ${b.duration} hrs</span>
            </div>` : '';

          // Driver name
          const driverName = isEvplan ? (b.assignedDriverName || 'Driver') : (b.driverName || 'Driver');
          const driverInfo = hasPhone || isEvplan ? `
            <div class="info">
              <i class="fas fa-user-tie"></i> 
              <span>Driver: ${driverName}</span>
            </div>` : '';

          // placeholder for review UI
          const reviewPlaceholder = `<span class="review-area" data-booking-id="${b.id}" data-driver-id="${b.driverId}"></span>`;
          const reviewedHtml = b.reviewed ? `<span class="reviewed-badge">Reviewed</span>` : '';

          return `
            <div class="booking-card" id="booking-card-${b.id}">
              <div class="card-number">${i + 1}</div>
              <h3>Booking #${i + 1}</h3>
              ${statusBadge}
              <div class="info"><i class="fas fa-calendar"></i> <span>${displayDate}</span></div>
              <div class="info"><i class="fas fa-clock"></i> <span>${displayTime}</span></div>
              <div class="info"><i class="fas fa-map-marker-alt"></i> <span>Pickup: ${pickup}</span></div>
              <div class="info"><i class="fas fa-flag-checkered"></i> <span>Dropoff: ${dropoff}</span></div>
              ${tripType}
              ${distanceInfo}
              ${driverInfo}
              <div class="info"><i class="fas fa-car"></i> <span>${carText}</span></div>

              <div class="fare-row">
                <div class="fare-text">Fare: ${fareText}</div>
                ${callBtn}
                ${reviewPlaceholder}
                ${reviewedHtml}
              </div>
            </div>`;
        }).join('');

        // Now process eligibility using server time
        const serverNow = await getServerTimeNow();
        myBookings.forEach(b => processBookingForReview(b, serverNow, user.uid));
      } catch (err) {
        console.error('Error fetching bookings:', err);
        bookingsEl.innerHTML = `<p style="color:#fff; text-align:center;">Unable to load bookings.</p>`;
      }
    });

    // Decide whether to show Review button, Reviewed badge, or waiting note
    async function processBookingForReview(b, serverNow, currentUid) {
      const placeholder = document.querySelector(`.review-area[data-booking-id="${b.id}"][data-driver-id="${b.driverId}"]`);
      if (!placeholder) return;

      // if bookings flag already set client-side
      if (b.reviewed) {
        placeholder.innerHTML = `<span class="reviewed-badge">Reviewed</span>`;
        return;
      }

      const pickupTs = getPickupTimestamp(b);
      if (!pickupTs) {
        placeholder.innerHTML = `<span class="fare-note">Review available after ride</span>`;
        return;
      }

      const tenMin = 10 * 60 * 1000;
      const eligible = serverNow >= (pickupTs + tenMin);
      if (!eligible) {
        const minutesLeft = Math.max(0, Math.ceil((pickupTs + tenMin - serverNow) / 60000));
        placeholder.innerHTML = `<span class="fare-note">Review available in ${minutesLeft} min</span>`;
        return;
      }

      // final check: is review already present in DB?
      try {
        const snap = await db.ref(`reviews/${b.driverId}/${b.id}`).once('value');
        if (snap.exists()) {
          placeholder.innerHTML = `<span class="reviewed-badge">Reviewed</span>`;
          return;
        }

        const btn = document.createElement('button');
        btn.className = 'review-btn';
        btn.innerHTML = `<i class="fas fa-star"></i> Review Driver`;
        btn.setAttribute('data-booking-id', b.id);
        btn.setAttribute('data-driver-id', b.driverId);

        btn.addEventListener('click', () => {
          window.openReviewModal({ id: b.id, ...b }, b.driverId);
        });

        placeholder.innerHTML = '';
        placeholder.appendChild(btn);
      } catch (err) {
        console.error('Error checking review existence', err);
        placeholder.innerHTML = `<span class="fare-note">Unable to check review</span>`;
      }
    }

    // ------------------ full client-only review flow ------------------
    // Steps:
    // 1) ensure bookings/.../pickupTime exists (server rule needs it)
    // 2) create reviews/{driverId}/{bookingId}
    // 3) create driverStatsUpdates/{driverId}/{bookingId} {userId,rating,createdAt,consumed:false}
    // 4) transaction on driverStats/{driverId} to increment count & sum and compute average AND include fromBookingId/fromRating
    // 5) set driverStatsUpdates/.../consumed = true
    // 6) set bookings/.../reviewed = true

    async function fullClientReviewFlow(booking, driverId, rating, comment) {
      const user = auth.currentUser;
      if (!user) throw new Error('Not authenticated');

      const bookingRef = db.ref(`bookings/${driverId}/${booking.id}`);
      const reviewRef = db.ref(`reviews/${driverId}/${booking.id}`);
      const updateRef = db.ref(`driverStatsUpdates/${driverId}/${booking.id}`);
      const statsRef = db.ref(`driverStats/${driverId}`);
      const bookingReviewedRef = db.ref(`bookings/${driverId}/${booking.id}/reviewed`);

      // 1) ensure pickupTime exists in DB (compute & update if missing)
      try {
        const snapBooking = await bookingRef.once('value');
        const dbBooking = snapBooking.val() || {};
        if (!dbBooking.pickupTime || isNaN(Number(dbBooking.pickupTime))) {
          // compute from the booking data we have (prefers server copy if available)
          const ts = getPickupTimestamp(Object.assign({}, dbBooking, booking));
          if (!ts) throw new Error('Cannot determine booking pickup time for server-side rule. Contact support.');
          await bookingRef.update({ pickupTime: ts });
          // also update local booking object
          booking.pickupTime = ts;
        }
      } catch (err) {
        throw new Error('Failed to ensure pickupTime: ' + (err && err.message ? err.message : err));
      }

      // check again server-time eligibility before sending review
      const serverNow = await getServerTimeNow();
      const pickupTsFinal = getPickupTimestamp(booking);
      if (!pickupTsFinal || serverNow < (pickupTsFinal + 10 * 60 * 1000)) {
        throw new Error('Review not yet allowed by server time. Try again later.');
      }

      // 2) ensure no existing review
      const existing = await reviewRef.once('value');
      if (existing.exists()) throw new Error('Review already exists for this booking.');

      // 3) write the review
      const reviewObj = {
        userId: user.uid,
        rating: Number(rating),
        comment: comment || '',
        createdAt: firebase.database.ServerValue.TIMESTAMP
      };

      await reviewRef.set(reviewObj);

      // 4) create the driverStatsUpdates entry (create-only; consumed false)
      const updateObj = {
        userId: user.uid,
        rating: Number(rating),
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        consumed: false
      };

      await updateRef.set(updateObj);

      // 5) transaction on statsRef - produce object with fromBookingId/fromRating so it satisfies rules
      await new Promise((resolve, reject) => {
        statsRef.transaction(current => {
          const r = Number(rating);
          if (current === null) {
            return { count: 1, sum: r, average: r, fromBookingId: booking.id, fromRating: r };
          } else {
            const curCount = (typeof current.count === 'number') ? current.count : 0;
            const curSum = (typeof current.sum === 'number') ? current.sum : 0;
            const nextCount = curCount + 1;
            const nextSum = curSum + r;
            const nextAverage = nextSum / nextCount;
            return { count: nextCount, sum: nextSum, average: nextAverage, fromBookingId: booking.id, fromRating: r };
          }
        }, async (error, committed, snapshot) => {
          if (error) {
            console.error('Transaction failed:', error);
            reject(error || new Error('Transaction failed'));
            return;
          }
          if (!committed) {
            reject(new Error('Transaction not committed'));
            return;
          }
          // transaction succeeded
          try {
            // 6) mark update consumed
            await updateRef.child('consumed').set(true);

            // 7) mark booking reviewed (rules allow this only if review exists and userId matches)
            await bookingReviewedRef.set(true);

            // done
            toast('Review submitted — thank you!');
            resolve();
          } catch (err2) {
            console.error('Post-transaction steps failed', err2);
            reject(err2);
          }
        }, /* applyLocally */ false);
      });

      // update UI: replace button with Reviewed badge
      const placeholder = document.querySelector(`.review-area[data-booking-id="${booking.id}"][data-driver-id="${driverId}"]`);
      if (placeholder) placeholder.innerHTML = `<span class="reviewed-badge">Reviewed</span>`;
    }

    // ------------------ end of script ------------------
  </script>

</body>
</html>
