<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WaveTravel Admin Dashboard</title>

  <!-- Normalize & DataTables CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css" />
  <link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.3.6/css/buttons.dataTables.min.css" />
  <link rel="stylesheet" href="https://cdn.datatables.net/responsive/2.4.1/css/responsive.dataTables.min.css" />

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --primary:#3498db;
      --card-bg: rgba(255,255,255,0.06);
      --muted:#cbd5e1;
    }
    body { font-family:Arial,sans-serif; margin:0; background:linear-gradient(135deg,#0f1724 0%, #0b3b6b 100%); color:#fff; }
    .navbar { display:flex; flex-wrap:wrap; background:#071124; padding:0.75rem; gap:.4rem; position:sticky; top:0; z-index:1000; border-bottom:1px solid rgba(255,255,255,0.03);}
    .navbar button { flex:1; padding:.5rem .75rem; border:none; border-radius:6px; background:var(--primary); color:#fff; cursor:pointer; font-weight:600; box-shadow:0 2px 6px rgba(0,0,0,0.35); }
    .tab-pane { display:none; padding:1rem; overflow:auto; max-height:calc(100vh - 64px); }
    .tab-pane.active { display:block; }
    .loading { text-align:center; margin:2rem; color:#ffd700; }

    table.dataTable { background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; color:#000; }
    .dt-button, .dataTables_length select, .dataTables_filter input { color:#000 !important; }

    /* DRIVER WALLETS UI */
    #driver-wallets-container { display:flex; flex-direction:column; gap:12px; padding-bottom: 40px; }
    .driver-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      box-shadow: 0 6px 18px rgba(3,10,20,0.45);
      overflow: hidden;
    }
    .driver-header {
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:12px 16px;
    }
    .driver-info { display:flex; gap:12px; align-items:center; }
    .driver-meta { display:flex; flex-direction:column; line-height:1; }
    .driver-meta small { color:var(--muted); }
    .driver-totals { text-align:right; min-width:180px; }
    .driver-totals h4 { margin:0; color:#ffd700; font-size:1.05rem; }
    .unpaid-badge { background:#ff6b6b; color:#fff; padding:6px 10px; border-radius:12px; font-weight:700; margin-left:8px; display:inline-block; font-size:0.9rem; }

    .driver-actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-left:12px; }
    .driver-actions .btn { font-weight:600; }

    .driver-body { padding: 10px 16px 16px; border-top:1px solid rgba(255,255,255,0.02); background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent); }
    .entries-table { background:transparent; color:#fff; }
    .entries-table thead th { color:#fff; background: rgba(0,0,0,0.15); }
    .badge-paid { background:#2ecc71; color:#012106; font-weight:700; padding:5px 8px; border-radius:10px; }
    .badge-unpaid { background:#ff6b6b; color:#2a0202; font-weight:700; padding:5px 8px; border-radius:10px; }
    .small-muted { color:var(--muted); font-size:0.9rem; }

    @media (max-width:900px){
      .driver-header { flex-direction:column; align-items:flex-start; gap:8px; }
      .driver-totals { width:100%; text-align:left; }
      .driver-actions { width:100%; justify-content:flex-start; }
    }

    /* filter controls */
    .wallets-filter-row { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    .wallets-filter-row select { padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#071124; color:#fff; font-weight:600; }
    .wallets-filter-row label { color:#fff; font-weight:700; margin-right:6px; }
  </style>
</head>
<body>

  <div class="navbar">
    <button onclick="openTab('users')">Users</button>
    <button onclick="openTab('drivers')">Drivers</button>
    <button onclick="openTab('pending-cars')">Pending Cars</button>
    <button onclick="openTab('approved-cars')">Approved Cars</button>
    <button onclick="openTab('slots')">Slots</button>
    <button onclick="openTab('bookings')">Bookings</button>
    <button onclick="openTab('driver-wallets')">Driver Wallets</button>
    <button onclick="openTab('pending-withdrawals')">Pending Withdrawals</button>
    <button onclick="openTab('profile')">Profile</button>
    <button onclick="logout()">Logout</button>
  </div>

  <!-- USERS -->
  <div id="users-tab" class="tab-pane">
    <h2>Users</h2>
    <div id="users-loading" class="loading">Loading users…</div>
    <table id="users-table" class="display responsive nowrap" style="width:100%;display:none">
      <thead><tr>
        <th>SL</th><th>User ID</th><th>Name</th><th>Email</th><th>Phone</th><th>Address</th><th>Created On</th><th>Action</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- DRIVERS -->
  <div id="drivers-tab" class="tab-pane">
    <h2>Drivers</h2>
    <div id="drivers-loading" class="loading">Loading drivers…</div>
    <table id="drivers-table" class="display responsive nowrap" style="width:100%;display:none">
      <thead><tr>
        <th>SL</th><th>Driver ID</th><th>Name</th><th>Phone</th><th>Vehicle Count</th><th>Action</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- PENDING CARS -->
  <div id="pending-cars-tab" class="tab-pane">
    <h2>Pending Cars</h2>
    <div id="pending-loading" class="loading">Loading pending cars…</div>
    <table id="pending-table" class="display responsive nowrap" style="width:100%;display:none">
      <thead><tr>
        <th>SL</th><th>Driver ID</th><th>Car ID</th><th>Brand</th><th>Reg No</th>
        <th>Driver Name</th><th>Driver Number</th><th>Owner Name</th><th>Seats</th><th>Submitted At</th><th>Actions</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- APPROVED CARS -->
  <div id="approved-cars-tab" class="tab-pane">
    <h2>Approved Cars</h2>
    <div id="approved-loading" class="loading">Loading approved cars…</div>
    <table id="approved-table" class="display responsive nowrap" style="width:100%;display:none">
      <thead><tr>
        <th>SL</th><th>Driver Name</th><th>Phone</th><th>Car ID</th>
        <th>Brand</th><th>Reg No</th><th>Owner</th><th>Seats</th><th>Action</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- SLOTS -->
  <div id="slots-tab" class="tab-pane">
    <h2>Slots</h2>
    <div id="slots-loading" class="loading">Loading slots…</div>
    <table id="slots-table" class="display responsive nowrap" style="width:100%;display:none">
      <thead><tr>
        <th>SL</th><th>Driver Name</th><th>Phone</th><th>Slot ID</th>
        <th>Pickup</th><th>Dropoff</th><th>Date</th><th>Time</th><th>Seats</th><th>Action</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- BOOKINGS -->
  <div id="bookings-tab" class="tab-pane">
    <h2>Bookings</h2>
    <div id="bookings-loading" class="loading">Loading bookings…</div>
    <table id="bookings-table" class="display responsive nowrap" style="width:100%;display:none">
      <thead><tr>
        <th>SL</th><th>Booking ID</th><th>Customer</th><th>Vehicle</th><th>Pickup</th>
        <th>Dropoff</th><th>Duration</th><th>Fare</th><th>Status</th><th>Action</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- DRIVER WALLETS -->
  <div id="driver-wallets-tab" class="tab-pane">
    <h2>Driver Wallets</h2>

    <!-- STATUS FILTER -->
    <div class="wallets-filter-row">
      <label for="walletStatusFilter">Filter by status</label>
      <select id="walletStatusFilter" aria-label="Filter wallet entries by status">
        <option value="processing" selected>Processing (ideal)</option>
        <option value="unpaid">Unpaid</option>
        <option value="paid">Paid</option>
      </select>
      <button id="walletFilterApplyBtn" class="btn btn-sm btn-light">Apply</button>
      <small style="margin-left:12px;color:#cbd5e1">Showing entries that match the selected status (evaluated from driverWallet entries only).</small>
    </div>

    <div id="wallets-loading" class="loading">Loading wallets…</div>
    <div id="driver-wallets-container" style="display:none;"></div>
  </div>

  <!-- PENDING WITHDRAWALS -->
  <div id="pending-withdrawals-tab" class="tab-pane">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
      <h2>Pending Withdrawals</h2>
      <div>
        <button id="exportWithdrawalsBtn" class="btn btn-sm btn-light">Export CSV (Grouped)</button>
      </div>
    </div>
    <div id="withdrawals-loading" class="loading">Loading pending withdrawals…</div>
    <div id="withdrawals-container" style="display:none;"></div>
  </div>

  <!-- PROFILE -->
  <div id="profile-tab" class="tab-pane">
    <h2>My Profile</h2>
    <div id="profile-loading" class="loading">Loading profile…</div>
    <table id="profile-table" class="display responsive nowrap" style="width:100%;display:none">
      <thead><tr><th>Field</th><th>Value</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Booking details modal -->
  <div class="modal fade" id="bookingDetailsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Booking Details</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body" id="bookingDetailsBody"></div>
      </div>
    </div>
  </div>

  <!-- QR Modal -->
  <div class="modal fade" id="qrModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content text-center p-3" id="qrModalContent" style="background:#0b1220;color:#ffd700;">
        <h5>UPI Payment QR</h5>
        <div id="qrCode" class="my-3"></div>
        <div id="qrInfo" class="mb-2"></div>
        <div id="upiUriBox" class="mb-2"></div>
        <div style="display:flex;gap:8px;justify-content:center;">
          <button id="copyUpiUriBtn" class="btn btn-sm btn-outline-light">Copy Minimal UPI URI</button>
          <button id="copyFullUpiUriBtn" class="btn btn-sm btn-outline-light">Copy Full UPI URI</button>
          <button type="button" class="btn btn-light btn-sm" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast container -->
  <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

  <!-- jQuery & DataTables JS -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
  <script src="https://cdn.datatables.net/buttons/2.3.6/js/dataTables.buttons.min.js"></script>
  <script src="https://cdn.datatables.net/responsive/2.4.1/js/dataTables.responsive.min.js"></script>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

  <!-- QRCode.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <!-- Firebase modular SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
    import { getDatabase, ref, get, update, remove, set } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-database.js";

    const cfg = {
      apiKey: "AIzaSyDsn16p7w8b-x8pEA_WTO5F2oUk4MHwcUc",
      authDomain: "wavetravel-3c4c4.firebaseapp.com",
      databaseURL: "https://wavetravel-3c4c4-default-rtdb.firebaseio.com",
      projectId: "wavetravel-3c4c4",
      storageBucket: "wavetravel-3c4c4.appspot.com",
      messagingSenderId: "298226098137",
      appId: "1:298226098137:web:720953b80e3e61c8bc43c8"
    };
    const app = initializeApp(cfg);
    const auth = getAuth(app);
    const db = getDatabase(app);

    const tables = {};
    function initTable(id,noSortCols=[]){
      if(!tables[id]){
        tables[id] = $(`#${id}`).DataTable({
          responsive:true,
          dom:'Bfltip',
          buttons:['copy','csv','print'],
          columnDefs: noSortCols.map(c=>({ orderable:false, targets:c }))
        });
      } else tables[id].clear().draw();
    }

    window.logout = () => signOut(auth).then(() => location.href='adminlogin.html');

    function showToast(message, type='info', timeout=3000){
      const id = 't' + Date.now();
      const toastHtml = `
        <div id="${id}" class="toast align-items-center text-bg-${type} border-0 mb-2" role="alert" aria-live="assertive" aria-atomic="true">
          <div class="d-flex">
            <div class="toast-body">${message}</div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
        </div>`;
      const container = document.getElementById('toast-container');
      container.insertAdjacentHTML('beforeend', toastHtml);
      const toastEl = document.getElementById(id);
      const bsToast = new bootstrap.Toast(toastEl, { delay: timeout });
      bsToast.show();
      toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
    }

    // CRUD and action functions
    window.deleteUser = async uid => { if(!confirm('Delete user?')) return; await remove(ref(db,`users/${uid}`)); loadUsers(); showToast('User deleted','success'); };
    window.deleteDriver = async did => { if(!confirm('Delete driver?')) return; await remove(ref(db,`driverdetails/${did}`)); loadDrivers(); showToast('Driver deleted','success'); };
    window.deletePending = async (did,cid) => { if(!confirm('Delete pending car?')) return; await remove(ref(db,`pendingcars/${did}/${cid}`)); loadPending(); showToast('Pending car deleted','success'); };
    window.deleteApproved = async (did,cid) => { if(!confirm('Delete approved car?')) return; await remove(ref(db,`approvedcars/${did}/${cid}`)); loadApproved(); showToast('Approved car deleted','success'); };
    window.deleteSlot = async (did,sid) => { if(!confirm('Delete slot?')) return; await remove(ref(db,`availableslots/${did}/${sid}`)); loadSlots(); showToast('Slot deleted','success'); };
    window.deleteBooking = async bid => { if(!confirm('Delete booking?')) return; await remove(ref(db,`bookings/${bid}`)); loadBookings(); showToast('Booking deleted','success'); };
    window.approveCar = async (did,cid) => { if(!confirm('Approve car?')) return; const snap = await get(ref(db,`pendingcars/${did}/${cid}`)); const car = snap.val(); if(!car) return; await set(ref(db,`approvedcars/${did}/${cid}`), car); await remove(ref(db,`pendingcars/${did}/${cid}`)); loadPending(); showToast('Car approved','success'); };

    // Wallet actions
    window.approveWalletEntry = async (driverId, bookingId) => {
      if (!confirm(`Mark booking ${bookingId} for driver ${driverId} as paid?`)) return;
      await update(ref(db,`driverWallet/${driverId}/${bookingId}`), { paidout: true, status: 'paid' });
      await set(ref(db, `adminActions/${Date.now()}`), { adminUid: auth.currentUser?.uid||null, action: 'approveWalletEntry', driverId, bookingId, ts: Date.now() });
      loadWallets();
      showToast('Marked paid','success');
    };
    window.rejectWalletEntry = async (driverId, bookingId, amount) => {
      if (!confirm(`Reject wallet entry ${bookingId} and reset amount to ${amount}?`)) return;
      await update(ref(db,`driverWallet/${driverId}/${bookingId}`), { status: 'available', amount });
      await set(ref(db, `adminActions/${Date.now()}`), { adminUid: auth.currentUser?.uid||null, action: 'rejectWalletEntry', driverId, bookingId, amount, ts: Date.now() });
      loadWallets();
      showToast('Wallet entry rejected','warning');
    };

    // If your flows still include pendingWithdrawals, these helpers remain useful
    window.approveWithdrawal = async (driverId, bookingId) => {
      if (!confirm(`Approve withdrawal ${bookingId} for driver ${driverId}?`)) return;
      await update(ref(db,`pendingWithdrawals/${driverId}/${bookingId}`), { 'status': 'approved' });
      await set(ref(db, `adminActions/${Date.now()}`), { adminUid: auth.currentUser?.uid||null, action: 'approveWithdrawal', driverId, bookingId, ts: Date.now() });
      loadWithdrawals();
      showToast('Withdrawal approved','success');
    };
    window.rejectWithdrawal = async (driverId, bookingId) => {
      if (!confirm(`Reject withdrawal ${bookingId} for driver ${driverId}?`)) return;
      await update(ref(db,`pendingWithdrawals/${driverId}/${bookingId}`), { 'status': 'rejected' });
      await set(ref(db, `adminActions/${Date.now()}`), { adminUid: auth.currentUser?.uid||null, action: 'rejectWithdrawal', driverId, bookingId, ts: Date.now() });
      loadWithdrawals();
      showToast('Withdrawal rejected','warning');
    };

    // Data loaders
    async function loadUsers(){ $('#users-table').hide(); $('#users-loading').show(); initTable('users-table',[7]); const snap = await get(ref(db,'users')); let i=1; if(snap.exists()) for(const [uid,u] of Object.entries(snap.val())){ tables['users-table'].row.add([i++,uid,u.name||'',u.email||'',u.phone||'',u.address||'',u.createdOn||'',`<button class="btn btn-sm btn-danger" onclick="deleteUser('${uid}')">Delete</button>`]).draw(false); } $('#users-loading').hide(); $('#users-table').show();}
    async function loadDrivers(){ $('#drivers-table').hide(); $('#drivers-loading').show(); initTable('drivers-table',[5]); const snap = await get(ref(db,'driverdetails')); let i=1; if(snap.exists()) for(const [did,d] of Object.entries(snap.val())){ const vc = d.vehicles?Object.keys(d.vehicles).length:0; tables['drivers-table'].row.add([i++,did,d.name||'',d.phone||'',vc,`<button class="btn btn-sm btn-danger" onclick="deleteDriver('${did}')">Delete</button>`]).draw(false); } $('#drivers-loading').hide(); $('#drivers-table').show();}
    async function loadPending(){ $('#pending-table').hide(); $('#pending-loading').show(); initTable('pending-table',[10]); const snap = await get(ref(db,'pendingcars')); let i=1; if(snap.exists()) for(const [did,cars] of Object.entries(snap.val())){ for(const [cid,c] of Object.entries(cars)){ tables['pending-table'].row.add([ i++,did,cid,c.carBrand||'',c.carReg||'',c.driverName||'',c.driverNumber||'',c.ownerName||'',c.seats||'',c.submittedAt||'', `<button class="btn btn-sm btn-success" onclick="approveCar('${did}','${cid}')">Approve</button> <button class="btn btn-sm btn-danger" onclick="deletePending('${did}','${cid}')">Delete</button>` ]).draw(false); } } $('#pending-loading').hide(); $('#pending-table').show();}
    async function loadApproved(){ $('#approved-table').hide(); $('#approved-loading').show(); initTable('approved-table',[8]); const snap = await get(ref(db,'approvedcars')); let i=1; if(snap.exists()) for(const [did,cars] of Object.entries(snap.val())){ for(const [cid,c] of Object.entries(cars)){ tables['approved-table'].row.add([i++,c.driverName||'',c.driverNumber||'',cid,c.carBrand||'',c.carReg||'',c.ownerName||'',c.seats||'',`<button class="btn btn-sm btn-danger" onclick="deleteApproved('${did}','${cid}')">Delete</button>`]).draw(false); } } $('#approved-loading').hide(); $('#approved-table').show();}
    async function loadSlots(){ $('#slots-table').hide(); $('#slots-loading').show(); initTable('slots-table',[9]); const snap = await get(ref(db,'availableslots')); let i=1; if(snap.exists()) for(const [did,slots] of Object.entries(snap.val())){ const dSnap = await get(ref(db,`driverdetails/${did}`)); const d = dSnap.exists()?dSnap.val():{}; for(const [sid,s] of Object.entries(slots)){ tables['slots-table'].row.add([i++,d.name||'',d.phone||'',sid,s.pickup||'',s.dropoff||'',s.date||'',s.time||'',s.seats||'',`<button class="btn btn-sm btn-danger" onclick="deleteSlot('${did}','${sid}')">Delete</button>`]).draw(false); } } $('#slots-loading').hide(); $('#slots-table').show();}

    // Helper: safe stringify for objects (short)
    function safeDisplay(val){
      if(val === null || val === undefined) return '';
      if(typeof val === 'object'){
        try {
          const s = JSON.stringify(val);
          if(s.length > 120) return s.slice(0,120) + '...';
          return s;
        } catch(e){
          return String(val);
        }
      }
      return String(val);
    }

    // helper to pick first available field from a list
    function pickField(obj, candidates){
      for(const key of candidates){
        // nested path support like 'booking.user.name'
        if(key.includes('.')){
          const parts = key.split('.');
          let cur = obj;
          let ok = true;
          for(const p of parts){
            if(cur && (p in cur)) cur = cur[p];
            else { ok = false; break; }
          }
          if(ok && cur !== undefined && cur !== null) return cur;
        } else {
          if(obj && (key in obj) && obj[key] !== undefined && obj[key] !== null && obj[key] !== '') return obj[key];
        }
      }
      return null;
    }

    // Determine effective status from driverWallet entry ONLY
    function getEffectiveStatusFromWalletEntry(entry){
      if(!entry) return 'unpaid';
      if(entry.status) return String(entry.status).toLowerCase();
      if(entry.paidout === true) return 'paid';

      // Common possible withdrawal request flags
      const flags = ['withdrawalRequested','withdrawal_requested','requested','request','pendingWithdrawal','withdrawRequested','withdraw_requested','withdrawRequest'];
      for(const f of flags){
        if(entry[f] === true) return 'processing';
      }

      // presence of requestedAt/requestedOn/requestTimestamp
      if(entry.requestedAt || entry.requestedOn || entry.requestTimestamp || entry.request_ts) return 'processing';

      return 'unpaid';
    }

    // ------------------ Driver Wallets (GROUPED PER DRIVER) - QR only for 'processing' ------------------
    async function loadWallets(){
      $('#driver-wallets-container').hide(); $('#wallets-loading').show();
      const container = document.getElementById('driver-wallets-container');
      container.innerHTML = '';

      const statusFilter = (document.getElementById('walletStatusFilter')?.value || 'processing').toString().toLowerCase();

      // Read driverWallet once
      const walletSnap = await get(ref(db,'driverWallet'));
      if(!walletSnap.exists()){
        container.textContent = 'No wallet entries found.';
        $('#wallets-loading').hide(); $('#driver-wallets-container').show();
        return;
      }
      const allDrivers = walletSnap.val();

      // iterate drivers and compute filtered entries map
      for(const [driverId, entries] of Object.entries(allDrivers)){
        const entriesToShow = {}; // bookingId -> { entry, effective }

        for(const [bookingId, e] of Object.entries(entries)){
          const effective = getEffectiveStatusFromWalletEntry(e);
          if(effective === statusFilter){
            entriesToShow[bookingId] = { entry: e, effective };
          }
        }

        // skip drivers with no matched entries
        if (Object.keys(entriesToShow).length === 0) continue;

        // fetch driver details (UPI/name)
        let upi = null, driverName = null;
        try {
          const dSnap = await get(ref(db, `driverdetails/${driverId}`));
          if(dSnap.exists()){
            const d = dSnap.val();
            upi = (typeof d.upiId === 'string') ? d.upiId.trim() : (d.upiId || null);
            driverName = d.name || null;
          }
        } catch (e) {
          upi = null; driverName = null;
        }

        // compute totals from filtered entries
        let totalFiltered = 0;
        // Also compute totalProcessing (sum only entries that are processing)
        let totalProcessing = 0;
        for(const [bid, obj] of Object.entries(entriesToShow)){
          const amt = parseFloat(obj.entry.amount) || 0;
          totalFiltered += amt;
          if(obj.effective === 'processing') totalProcessing += amt;
        }

        // build driver card
        const card = document.createElement('div');
        card.className = 'driver-card';

        const sanitized = sanitizeId(driverId);
        const header = document.createElement('div');
        header.className = 'driver-header';
        header.innerHTML = `
          <div class="driver-info">
            <div class="driver-meta">
              <strong>${driverName ? `${driverName}` : driverId}</strong>
              <small class="small-muted">${driverId}</small>
              <small class="small-muted">UPI: <span id="upi-val-${sanitized}">${upi ? upi : '—'}</span></small>
            </div>
          </div>

          <div style="display:flex;align-items:center;gap:12px;">
            <div class="driver-totals">
              <h4>₹${totalFiltered.toFixed(2)}</h4>
              <div class="small-muted">Total (${escapeHtml(statusFilter)})</div>
            </div>
            <div style="display:flex;flex-direction:column;align-items:flex-end;">
              <div>
                <span class="small-muted">Listed</span>
                <span class="unpaid-badge">₹${totalFiltered.toFixed(2)}</span>
              </div>
              <div class="driver-actions" style="margin-top:8px;">
                <button class="btn btn-sm btn-outline-light" id="copy-upi-${sanitized}" ${upi? '': 'disabled'}>Copy UPI</button>
                <!-- Show total QR only when there are processing entries and driver has UPI -->
                <button class="btn btn-sm btn-primary" id="qr-total-${sanitized}" ${(!upi || totalProcessing <= 0) ? 'disabled' : ''}>Show QR (Processing Total)</button>
                <button class="btn btn-sm btn-success" id="mark-all-paid-${sanitized}">Mark All Paid</button>
              </div>
            </div>
          </div>
        `;
        card.appendChild(header);

        // body with entries table (for filtered entries)
        const body = document.createElement('div');
        body.className = 'driver-body';
        const tbl = document.createElement('table');
        tbl.className = 'table table-sm entries-table';
        tbl.innerHTML = `<thead><tr><th>SL</th><th>Booking</th><th>Amount</th><th>Fare</th><th>Status</th><th>Actions</th></tr></thead><tbody></tbody>`;
        const tbody = tbl.querySelector('tbody');

        let i = 1;
        for(const [bookingId, obj] of Object.entries(entriesToShow)){
          const entry = obj.entry;
          const effective = obj.effective;
          const amount = entry.amount !== undefined ? Number(entry.amount) : NaN;
          const fare = (entry.fare ?? (entry.booking?.fare)) ?? 'N/A';
          const paidoutFlag = entry.paidout === true;
          const isPaid = paidoutFlag || (String(effective).toLowerCase() === 'paid');

          const bookingData = entry.booking || entry.bookingdata || {};
          const pickup = bookingData.pickup || entry.pickup || 'N/A';
          const dropoff = bookingData.dropoff || entry.dropoff || 'N/A';

          const tr = document.createElement('tr');

          // actions cell
          const actionsCell = document.createElement('td');
          actionsCell.style.whiteSpace = 'nowrap';

          // Show button
          const btnShow = document.createElement('button');
          btnShow.className = 'btn btn-sm btn-info me-1';
          btnShow.textContent = 'Show';
          btnShow.onclick = () => showBookingModal(driverId, bookingId);
          actionsCell.appendChild(btnShow);

          // QR button: now enabled ONLY when entry effective status === 'processing' AND not paid AND amount>0 AND upi exists
          const btnQr = document.createElement('button');
          btnQr.className = 'btn btn-sm btn-primary me-1';
          btnQr.textContent = 'QR';
          const allowQr = (effective === 'processing') && !isPaid && (Number(amount) > 0) && !!upi;
          if(!upi){ btnQr.disabled = true; btnQr.title = 'UPI missing'; }
          else if(!allowQr){ btnQr.disabled = true; btnQr.title = 'QR allowed only for processing entries with amount > 0'; }
          else btnQr.onclick = () => showQrModal(driverId, isNaN(amount) ? 0 : amount, bookingId);
          actionsCell.appendChild(btnQr);

          // Mark Paid: allowed to mark - still available
          const btnPaid = document.createElement('button');
          btnPaid.className = 'btn btn-sm btn-success';
          btnPaid.textContent = 'Mark Paid';
          btnPaid.onclick = () => markPaidEntry(driverId, bookingId);
          actionsCell.appendChild(btnPaid);

          tr.innerHTML = `<td>${i++}</td>
                          <td style="min-width:200px"><div><strong>${bookingId}</strong></div><small class="small-muted">${escapeHtml(pickup)} → ${escapeHtml(dropoff)}</small></td>
                          <td>₹${isNaN(amount) ? '0.00' : amount.toFixed(2)}</td>
                          <td>₹${fare}</td>
                          <td>${isPaid ? '<span class="badge-paid">Paid</span>' : `<span class="badge-unpaid">${escapeHtml(effective)}</span>`}</td>`;
          tr.appendChild(actionsCell);
          tbody.appendChild(tr);
        }

        body.appendChild(tbl);
        card.appendChild(body);
        container.appendChild(card);

        // wire up header buttons
        const copyBtn = document.getElementById(`copy-upi-${sanitized}`);
        if(copyBtn && upi){
          copyBtn.addEventListener('click', async () => {
            try { await navigator.clipboard.writeText(upi); showToast('UPI copied','success'); } catch (e) { showToast('Copy failed','danger'); }
          });
        }
        const qrTotalBtn = document.getElementById(`qr-total-${sanitized}`);
        // Only attach total QR listener if there are processing entries (we computed totalProcessing)
        if(qrTotalBtn && upi && !qrTotalBtn.disabled){
          // compute processing sum again for safety
          let processingSum = 0;
          for(const [bid, obj] of Object.entries(entriesToShow)){
            if(obj.effective === 'processing') processingSum += Number(obj.entry.amount) || 0;
          }
          if(processingSum > 0){
            qrTotalBtn.addEventListener('click', () => showQrModal(driverId, processingSum, '')); // bookingId empty => total QR for processing entries
          }
        }
        const markAllBtn = document.getElementById(`mark-all-paid-${sanitized}`);
        if(markAllBtn) markAllBtn.addEventListener('click', () => markAllPaidForDriver(driverId));
      }

      $('#wallets-loading').hide(); $('#driver-wallets-container').show();
    }

    // Booking modal builder
    async function showBookingModal(driverId, bookingId){
      try {
        const snap = await get(ref(db, `driverWallet/${driverId}/${bookingId}`));
        if(!snap.exists()){
          document.getElementById('bookingDetailsBody').innerHTML = `<div class="alert alert-warning">No booking data found for ${bookingId}</div>`;
          new bootstrap.Modal(document.getElementById('bookingDetailsModal')).show();
          return;
        }
        const entry = snap.val();
        const b = entry.booking || entry.bookingdata || entry;

        const rows = [
          ['Booking ID', bookingId],
          ['Driver ID', b.driverId || entry.driverId || driverId],
          ['Driver Name', b.driverName || entry.driverName || 'N/A'],
          ['User Name', b.userName || b.customerName || entry.userName || 'N/A'],
          ['User Phone', b.userPhone || entry.userPhone || 'N/A'],
          ['Pickup', b.pickup || 'N/A'],
          ['Dropoff', b.dropoff || 'N/A'],
          ['Date', b.date || entry.date || 'N/A'],
          ['Time', b.time || entry.time || 'N/A'],
          ['Booked At', b.bookedAt || entry.bookedAt || 'N/A'],
          ['Fare', b.fare || entry.fare || 'N/A'],
          ['Amount', entry.amount || 'N/A'],
          ['PaymentId', b.paymentId || entry.paymentId || 'N/A'],
          ['Status', entry.status || (entry.paidout ? 'paid' : ( entry.withdrawalRequested ? 'processing' : 'unpaid')) || 'N/A']
        ];

        let html = `<table class="table table-sm table-bordered">`;
        for(const [label, val] of rows){
          html += `<tr><th style="width:30%">${label}</th><td>${(val !== undefined && val !== null) ? escapeHtml(safeDisplay(val)) : 'N/A'}</td></tr>`;
        }
        html += `</table>`;
        document.getElementById('bookingDetailsBody').innerHTML = html;
        new bootstrap.Modal(document.getElementById('bookingDetailsModal')).show();
      } catch (err) {
        document.getElementById('bookingDetailsBody').innerHTML = `<div class="alert alert-danger">Error: ${err.message}</div>`;
        new bootstrap.Modal(document.getElementById('bookingDetailsModal')).show();
      }
    }

    // QR generation: blocks creation if booking entry already paid; otherwise generates QR
    async function showQrModal(driverId, amount, bookingId){
      try {
        const dSnap = await get(ref(db, `driverdetails/${driverId}`));
        if(!dSnap.exists()){
          showToast('Driver details not found','danger'); return;
        }
        const d = dSnap.val();
        let upiIdRaw = d.upiId;
        if(typeof upiIdRaw === 'string') upiIdRaw = upiIdRaw.trim();
        if(!upiIdRaw){ showToast('UPI ID not set for this driver.','warning'); return; }

        // If bookingId provided, check its paid status to prevent generating QR for paid entries
        if(bookingId){
          const wSnap = await get(ref(db, `driverWallet/${driverId}/${bookingId}`));
          if(wSnap.exists()){
            const w = wSnap.val();
            const st = (w.status ?? (w.paidout ? 'paid' : '') ) || '';
            const paidoutFlag = w.paidout === true;
            if(paidoutFlag || String(st).toLowerCase() === 'paid'){
              showToast('Cannot generate QR: entry already paid','warning');
              return;
            }
            // If effective status !== 'processing' disallow (extra safety)
            const eff = getEffectiveStatusFromWalletEntry(w);
            if(eff !== 'processing'){
              showToast('QR allowed only for processing entries','warning');
              return;
            }
          }
        } else {
          // bookingId empty => total QR. We do an additional check: ensure at least one 'processing' entry present
          // (caller should have computed totalProcessing; still check all wallet entries)
          const wSnap = await get(ref(db, `driverWallet/${driverId}`));
          if(wSnap.exists()){
            const wallet = wSnap.val();
            const anyProcessing = Object.values(wallet).some(e => getEffectiveStatusFromWalletEntry(e) === 'processing');
            if(!anyProcessing){
              showToast('No processing entries available for combined QR','warning');
              return;
            }
          }
        }

        const driverNameRaw = (d.name || driverId || 'Payee').trim();
        const payeeName = driverNameRaw.split(/\s+/).map(s => s ? (s[0].toUpperCase() + s.slice(1)) : '').join(' ');

        const paEncoded = encodeURIComponent(upiIdRaw);
        const pnEncoded = encodeURIComponent(payeeName);
        const amountStr = Number(amount) ? Number(amount).toFixed(2) : '0.00';

        const minimalUri = `upi://pay?pa=${paEncoded}&pn=${pnEncoded}&am=${encodeURIComponent(amountStr)}&cu=INR`;
        const tn = bookingId ? `Payment for ${bookingId}` : 'Withdrawal payment';
        const tr = bookingId || `txn${Date.now()}`;
        const fullUri = `upi://pay?pa=${paEncoded}&pn=${pnEncoded}&am=${encodeURIComponent(amountStr)}&tn=${encodeURIComponent(tn)}&tr=${encodeURIComponent(tr)}&cu=INR`;

        document.getElementById('qrCode').innerHTML = '';
        new QRCode(document.getElementById('qrCode'), {
          text: minimalUri,
          width: 340,
          height: 340,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.H
        });

        document.getElementById('qrInfo').innerHTML = `<small style="color:#fff">UPI: ${upiIdRaw} — ${payeeName} — Amount: ₹${amountStr}</small>`;
        document.getElementById('upiUriBox').innerHTML = `<div style="text-align:left"><strong>Minimal URI (used for QR):</strong><div style="margin-top:6px">${minimalUri}</div><hr style="border-color:rgba(255,255,255,0.06)"><strong>Full URI (fallback):</strong><div style="margin-top:6px">${fullUri}</div></div>`;

        document.getElementById('copyUpiUriBtn').onclick = async () => {
          try { await navigator.clipboard.writeText(minimalUri); showToast('Minimal UPI URI copied','success'); } catch (e){ showToast('Copy failed','danger'); }
        };
        document.getElementById('copyFullUpiUriBtn').onclick = async () => {
          try { await navigator.clipboard.writeText(fullUri); showToast('Full UPI URI copied','success'); } catch (e){ showToast('Copy failed','danger'); }
        };

        new bootstrap.Modal(document.getElementById('qrModal')).show();
      } catch (err) {
        showToast('Failed to generate QR: ' + (err.message || err),'danger');
      }
    }

    async function markPaidEntry(driverId, bookingId){
      if(!confirm(`Mark booking ${bookingId} for driver ${driverId} as paid?`)) return;
      try {
        await update(ref(db, `driverWallet/${driverId}/${bookingId}`), { paidout:true, status: 'paid' });
        await set(ref(db, `adminActions/${Date.now()}`), { adminUid: auth.currentUser?.uid||null, action: 'markPaidEntry', driverId, bookingId, ts: Date.now() });
        loadWallets();
        showToast('Marked paid','success');
      } catch (err) {
        showToast('Failed to mark paid: ' + (err.message || err),'danger');
      }
    }

    // mark all 'processing' entries for a driver as paid
    async function markAllPaidForDriver(driverId){
      if(!confirm(`Mark ALL 'processing' wallet entries for driver ${driverId} as paid?`)) return;
      try {
        const snap = await get(ref(db, `driverWallet/${driverId}`));
        if(!snap.exists()){ showToast('No wallet entries for this driver','warning'); return; }
        const entriesObj = snap.val();
        const updates = {};
        const bookingIds = [];

        for(const [bookingId, entry] of Object.entries(entriesObj)){
          const effective = getEffectiveStatusFromWalletEntry(entry);
          if(effective === 'processing'){
            updates[`driverWallet/${driverId}/${bookingId}/paidout`] = true;
            updates[`driverWallet/${driverId}/${bookingId}/status`] = 'paid';
            bookingIds.push(bookingId);
          }
        }

        if(Object.keys(updates).length === 0){
          showToast('No processing entries to mark paid','info');
          return;
        }

        await update(ref(db), updates);
        await set(ref(db, `adminActions/${Date.now()}`), { adminUid: auth.currentUser?.uid||null, action: 'markAllPaidForDriver', driverId, bookingIds, ts: Date.now() });
        showToast(`Marked ${bookingIds.length} booking(s) as paid for ${driverId}`,'success');
        loadWallets();
      } catch (err) {
        showToast('Failed to mark all paid: ' + (err.message || err),'danger');
      }
    }

    // Withdrawals loader (unchanged)
    async function loadWithdrawals(){
      $('#withdrawals-container').hide(); $('#withdrawals-loading').show();
      const container = document.getElementById('withdrawals-container');
      container.innerHTML='';

      const snap = await get(ref(db,'pendingWithdrawals'));
      if(!snap.exists()){
        container.textContent = 'No pending withdrawals found.';
        $('#withdrawals-loading').hide(); $('#withdrawals-container').show();
        return;
      }

      const byDriver = snap.val();

      for(const [driverId, bookingsObj] of Object.entries(byDriver)){
        let total = 0;
        for(const b of Object.values(bookingsObj)) total += Number(b.amount) || 0;

        let driverName = null, upi = null;
        try {
          const dSnap = await get(ref(db, `driverdetails/${driverId}`));
          if(dSnap.exists()){
            const d = dSnap.val();
            driverName = d.name || null;
            upi = (typeof d.upiId === 'string') ? d.upiId.trim() : (d.upiId || null);
          }
        } catch (e) { driverName = null; upi = null; }

        const hasUnpaid = Object.values(bookingsObj).some(b => {
          const st = (b.status || '').toString().toLowerCase();
          const paidoutFlag = b.paidout === true;
          return !paidoutFlag && st !== 'paid' && st !== 'approved';
        });

        const driverCard = document.createElement('div');
        driverCard.className = 'withdrawal-driver-card';
        driverCard.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
            <div>
              <h4 style="margin:0;color:#ffd700">Driver: ${driverId}${driverName ? ` — ${driverName}` : ''}</h4>
              <small style="color:#cbd5e1">UPI: <span id="upi-${driverId}">${upi ? upi : '—'}</span> ${!upi ? '<span class="badge-missing-upi">UPI missing</span>' : `<button id="copyUpi-${driverId}" class="btn btn-sm btn-outline-light ms-2">Copy UPI</button>`}</small>
            </div>
            <div style="text-align:right;">
              <h4 style="margin:0">Total: ₹${total.toFixed(2)}</h4>
              <div style="margin-top:6px;display:flex;gap:8px;justify-content:flex-end;">
                <button class="btn btn-sm btn-primary" ${(!upi || !hasUnpaid) ? 'disabled title="No unpaid withdrawals or UPI missing"' : ''} id="qrTotal-${driverId}">Show QR (Total)</button>
                <button class="btn btn-sm btn-success" id="markAllPaid-${driverId}">Mark All Paid</button>
              </div>
            </div>
          </div>
          <hr style="border-color: rgba(255,255,255,0.06)">
          <div id="withdrawals-list-${driverId}"></div>
        `;
        container.appendChild(driverCard);

        if(upi){
          const copyBtn = document.getElementById(`copyUpi-${driverId}`);
          if(copyBtn) copyBtn.addEventListener('click', async () => {
            try { await navigator.clipboard.writeText(upi); showToast('UPI copied','success'); } catch (e) { showToast('Copy failed','danger'); }
          });
        }
        const qrTotalBtn = document.getElementById(`qrTotal-${driverId}`);
        if(qrTotalBtn && upi && hasUnpaid){
          qrTotalBtn.addEventListener('click', () => showQrModal(driverId, total, ''));
        }

        document.getElementById(`markAllPaid-${driverId}`).addEventListener('click', () => markAllPaidForDriver(driverId));

        const listEl = driverCard.querySelector(`#withdrawals-list-${driverId}`);
        const tbl = document.createElement('table');
        tbl.className = 'table table-sm table-striped';
        tbl.innerHTML = `<thead><tr><th>SL</th><th>Booking</th><th>Amount</th><th>Fare</th><th>Status</th><th>Actions</th></tr></thead><tbody></tbody>`;
        listEl.appendChild(tbl);
        const tbody = tbl.querySelector('tbody');

        let i=1;
        for(const [bookingId, data] of Object.entries(bookingsObj)){
          const tr = document.createElement('tr');
          const pickup = (data.booking && data.booking.pickup) ? data.booking.pickup : (data.pickup || 'N/A');
          const dropoff = (data.booking && data.booking.dropoff) ? data.booking.dropoff : (data.dropoff || 'N/A');
          const amount = Number(data.amount) ? Number(data.amount).toFixed(2) : '0.00';
          const fare = data.fare ?? 'N/A';
          const status = data.status ?? 'pending';
          const paidoutFlag = data.paidout === true;
          const isPaid = paidoutFlag || (String(status).toLowerCase() === 'paid' || String(status).toLowerCase() === 'approved');

          const btnApprove = document.createElement('button');
          btnApprove.className = 'btn btn-sm btn-success';
          btnApprove.textContent = 'Approve';
          btnApprove.onclick = () => approveWithdrawal(driverId, bookingId);

          const btnReject = document.createElement('button');
          btnReject.className = 'btn btn-sm btn-danger';
          btnReject.textContent = 'Reject';
          btnReject.onclick = () => rejectWithdrawal(driverId, bookingId);

          const btnQrSingle = document.createElement('button');
          btnQrSingle.className = 'btn btn-sm btn-primary';
          btnQrSingle.textContent = 'Show QR';
          if(!upi){ btnQrSingle.disabled = true; btnQrSingle.title = 'UPI missing'; }
          else if(isPaid){ btnQrSingle.disabled = true; btnQrSingle.title = 'Already paid or approved'; }
          else btnQrSingle.onclick = () => showQrModal(driverId, Number(amount)||0, bookingId);

          const btnShowBooking = document.createElement('button');
          btnShowBooking.className = 'btn btn-sm btn-info';
          btnShowBooking.textContent = 'Show';
          btnShowBooking.onclick = () => showBookingModal(driverId, bookingId);

          const actionsWrapper = document.createElement('div');
          actionsWrapper.style.display = 'flex';
          actionsWrapper.style.gap = '6px';
          actionsWrapper.appendChild(btnShowBooking);
          actionsWrapper.appendChild(btnQrSingle);
          actionsWrapper.appendChild(btnApprove);
          actionsWrapper.appendChild(btnReject);

          tr.innerHTML = `<td>${i++}</td>
                          <td style="min-width:180px"><div><strong>${bookingId}</strong></div><small>${pickup} → ${dropoff}</small></td>
                          <td>₹${amount}</td>
                          <td>₹${fare}</td>
                          <td>${isPaid ? '<span class="badge-paid">Paid</span>' : '<span class="badge-unpaid">Unpaid</span>'}</td>
                          <td></td>`;
          tr.querySelector('td:last-child').appendChild(actionsWrapper);
          tbody.appendChild(tr);
        }
      }

      document.getElementById('exportWithdrawalsBtn').onclick = () => exportWithdrawalsGrouped(byDriver);

      $('#withdrawals-loading').hide(); $('#withdrawals-container').show();
    }

    function exportWithdrawalsGrouped(dataByDriver){
      try {
        let rows = [['Driver ID','Driver Name','UPI','Booking ID','Amount','Fare','Status']];
        for(const [driverId, bookingsObj] of Object.entries(dataByDriver)){
          for(const [bookingId, data] of Object.entries(bookingsObj)){
            const driverName = (data.driverName || '');
            const upi = (data.upi || '');
            rows.push([driverId, driverName, upi, bookingId, (Number(data.amount)||0).toFixed(2), (data.fare||''), (data.status||'')]);
          }
        }
        const csv = rows.map(r => r.map(cell => `"${String(cell||'').replace(/"/g,'""')}"`).join(',')).join('\r\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `pending_withdrawals_grouped_${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        set(ref(db, `adminActions/${Date.now()}`), { adminUid: auth.currentUser?.uid||null, action: 'exportWithdrawalsGrouped', ts: Date.now() });
        showToast('CSV exported','success');
      } catch (err) { showToast('Export failed: ' + (err.message || err),'danger'); }
    }

    // ---------- FIXED loadBookings() ----------
    async function loadBookings(){
      $('#bookings-table').hide(); $('#bookings-loading').show();
      initTable('bookings-table',[9]);

      try {
        const snap = await get(ref(db,'bookings'));
        if(!snap.exists()){
          $('#bookings-loading').hide();
          $('#bookings-table').show();
          return;
        }

        const data = snap.val();

        // helper to process a single booking record (bid, b)
        function processBookingRow(bid, b, idx){
          // Try many common field names to be robust to schema differences
          const customer = pickField(b, ['customerName','userName','customer','name','user','customer.name','user.name']) || '';
          // vehicle might be an object or string
          let vehicle = pickField(b, ['vehicle','car','vehicleInfo','carBrand','vehicle.brand','vehicle.model']) || '';
          if(typeof vehicle === 'object') {
            // try to create a compact representation
            vehicle = (vehicle.brand ? vehicle.brand + (vehicle.reg ? ' ('+vehicle.reg+')' : '') : (vehicle.reg || JSON.stringify(vehicle)));
          }
          const pickup = pickField(b, ['pickup','from','start','route.pickup','booking.pickup','pickupLocation']) || '';
          const dropoff = pickField(b, ['dropoff','to','end','route.dropoff','booking.dropoff','dropoffLocation']) || '';
          const duration = pickField(b, ['duration','tripDuration','timeTaken']) || '';
          const fare = pickField(b, ['fare','amount','price','booking.fare']) || '';
          const status = pickField(b, ['status','paymentStatus','state','bookingStatus']) || '';

          // fallback: if many are empty and b itself contains nested booking object, try deeper
          if(!customer && b.booking && typeof b.booking === 'object'){
            const bk = b.booking;
            const fallbackCustomer = pickField(bk, ['customerName','userName','name']) || '';
            if(fallbackCustomer) { customer = fallbackCustomer; }
          }

          // sanitize and display
          const displayCustomer = escapeHtml(safeDisplay(customer));
          const displayVehicle = escapeHtml(safeDisplay(vehicle));
          const displayPickup = escapeHtml(safeDisplay(pickup));
          const displayDropoff = escapeHtml(safeDisplay(dropoff));
          const displayDuration = escapeHtml(safeDisplay(duration));
          const displayFare = escapeHtml(safeDisplay(fare));
          const displayStatus = escapeHtml(safeDisplay(status));

          const actionHtml = `<button class="btn btn-sm btn-danger" onclick="deleteBooking('${bid}')">Delete</button>`;

          tables['bookings-table'].row.add([ idx, bid, displayCustomer, displayVehicle, displayPickup, displayDropoff, displayDuration, displayFare, displayStatus, actionHtml ]).draw(false);
        }

        // If top-level children look like booking objects (flat map), detect
        const values = Object.values(data);
        const looksFlat = values.some(v => v && (v.pickup || v.fare || v.customerName || v.userName || v.vehicle || v.booking));

        if(looksFlat){
          let i = 1;
          for(const [bid, b] of Object.entries(data)){
            processBookingRow(bid, b, i++);
          }
        } else {
          // Possibly grouped by driverId or some other grouping: iterate two levels deep
          let i = 1;
          for(const [groupKey, groupVal] of Object.entries(data)){
            if(groupVal && typeof groupVal === 'object'){
              for(const [bid, b] of Object.entries(groupVal)){
                processBookingRow(bid, b, i++);
              }
            } else {
              // last resort: the child is not object => show as row
              processBookingRow(groupKey, groupVal, i++);
            }
          }
        }
      } catch (err) {
        showToast('Failed to load bookings: ' + (err.message || err),'danger');
      } finally {
        $('#bookings-loading').hide();
        $('#bookings-table').show();
      }
    }
    // ---------- end loadBookings fix ----------

    // helper to make safe DOM id
    function sanitizeId(id){
      return String(id).replace(/[^a-z0-9\-_]/gi, '-');
    }

    // Basic HTML-escape
    function escapeHtml(str) {
      if (!str && str !== 0) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    async function loadProfile(){
      $('#profile-table').hide(); $('#profile-loading').show();
      initTable('profile-table');
      const user = auth.currentUser;
      const profileData = { Name: user?.displayName || 'Admin', Email: user?.email || '', UID: user?.uid || '' };
      for(const [k,v] of Object.entries(profileData)) tables['profile-table'].row.add([k,v]).draw(false);
      $('#profile-loading').hide(); $('#profile-table').show();
    }

    // Defensive openTab + ensure DOM ready when opening default tab
    window.openTab = function(tab){
      document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
      const id = `${tab}-tab`;
      const el = document.getElementById(id);
      if (!el) {
        const first = document.querySelector('.tab-pane');
        if (first) {
          first.classList.add('active');
          if (typeof loadUsers === 'function') loadUsers();
        }
        return;
      }
      el.classList.add('active');
      switch(tab){
        case 'users': if (typeof loadUsers === 'function') loadUsers(); break;
        case 'drivers': if (typeof loadDrivers === 'function') loadDrivers(); break;
        case 'pending-cars': if (typeof loadPending === 'function') loadPending(); break;
        case 'approved-cars': if (typeof loadApproved === 'function') loadApproved(); break;
        case 'slots': if (typeof loadSlots === 'function') loadSlots(); break;
        case 'bookings': if (typeof loadBookings === 'function') loadBookings(); break;
        case 'driver-wallets': if (typeof loadWallets === 'function') loadWallets(); break;
        case 'pending-withdrawals': if (typeof loadWithdrawals === 'function') loadWithdrawals(); break;
        case 'profile': if (typeof loadProfile === 'function') loadProfile(); break;
        default: console.warn('Unknown tab:', tab); break;
      }
    };

    // Ensure openTab runs after auth state ready
    onAuthStateChanged(auth, user => {
      if (!user) { location.href = 'adminlogin.html'; return; }
      const filterEl = document.getElementById('walletStatusFilter');
      if(filterEl){
        document.getElementById('walletFilterApplyBtn').addEventListener('click', () => loadWallets());
        filterEl.addEventListener('change', () => loadWallets());
      }
      const showDefault = () => openTab('users');
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', showDefault, { once: true });
      else showDefault();
    });
  </script>
</body>
</html>
